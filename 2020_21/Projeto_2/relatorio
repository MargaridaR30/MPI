Este projeto consiste em criar e implementar uma versão possível do Jogo da Forca.
Embora o principal objetivo tenha sido o de criar o Jogo da Forca (3.º programa- ficheiro “3.c”) foi-me pedido que criasse no total três programas. Neste caso o primeiro programa (ficheiro “1.c”) criado foi usado na criação do terceiro.
As bibliotecas usadas em todos os programas foram: #include <stdio.h>, #include <stdlib.h>, #include <string.h> e #include <time.h>.
O primeiro programa lê as componentes do ficheiro “ficheiro.txt”, neste caso palavras, e guarda-as no “vetor s” que está definido (com as devidas dimensões) como:
#define NUMBER_OF_STRING 40000
#define MAX_STRING_SIZE 20
Inicialmente defini o vetor de forma diferente, sendo que a única alteração era #define MAX_STRING_SIZE 80, mas devolvia o erro número “0xC00000FD”, pelo que, após alguma pesquisa, cheguei à conclusão de que o referido erro indicava que estava a haver um "stack overflow". Este erro significava que não havia espaço suficiente para executar o programa corretamente dado que, quando defini que o tamanho era 80, já estava a reservar o espaço todo, não sobrando espaço suficiente para executar tudo. Consequentemente, reduzi o tamanho de 80 para 20.
Seguidamente, para gerar um número inteiro “j” aleatório usei a função rand() que devolve um inteiro entre 0 e o total_linhas=i. Antes de usar esta função, usei a instrução srand(time(NULL)) que serve para gerar uma semente. Para usar a referida função e a instrução tive de usar as bibliotecas #include <stdlib.h> e #include <time.h>. Assim, “j” ficou definido da seguinte forma: j=(rand()%total_linhas ).
Para que aparecesse no ecrã o número de palavras lidas e ainda quantas letras tem a palavra guardada na j-ésima posição do “vetor s” criei as variáveis palavra_selecionada (do tipo string e para tal usei a biblioteca #include <string.h>) e comprimento, respetivamente (linhas 40-41 do “ficheiro 1.c”).
No segundo programa, “ficheiro 2.c”, implementei a função int ocorrencias(char p[], int l, char c, int ind[]) que devolve o número de vezes que o caracter “c” ocorre na palavra “p” de comprimento “l” e armazene os respetivos índices no “vetor ind”. Com base nesta função implementei um programa que pede ao utilizador que insira uma letra, devolvendo o número de ocorrências dessa letra na palavra selecionada anteriormente, e que escreve no ecrã quais as posições em que essa letra aparece.
O terceiro programa realizado é a minha versão do Jogo da Forca. Neste jogo, o jogador/utilizador tem de acertar qual a palavra do ficheiro “dicionario.txt” correspondente à posição “j” gerada pelo computador, tendo como dica o número de letras que a constituem. Cada jogador tem no total 10 créditos e, cada vez que insere uma letra que não constitua a palavra selecionada, perde um crédito. Durante a realização deste programa tive algumas
2
dificuldades e durante as minhas pesquisas encontrei uma nova definição, um buffer. Um buffer é uma área de armazenamento temporário que existe em todos os dispositivos de entrada e saída padrão (contêm um buffer de entrada e saída). Assim, por exemplo, quando pressionamos uma tecla no teclado, ela fica armazenada em buffer pelo sistema operacional. Em resultado desta situação, tive alguma dificuldade na execução do programa. Por exemplo: quando inseria uma letra e carregava em enter, o programa contava esse enter como mais de duas entradas e o jogo acabava muito mais cedo. Para solucionar os problemas detetados tive de usar fflush(stdin) para “esvaziar” o buufer do teclado. (Jain, 2018)
Nos três programas, caso o ficheiro “dicionario.txt” (neste caso) não exista, devido ao facto de ter criado um ciclo while, o utilizador será informado de que ocorreu um erro. Durante a programação dos programas constituintes do projeto fui usando um ficheiro de dicionário mais pequeno, com poucas palavras, para poder testar, com as funções de escrita de vetores, e conferir se estava a ler corretamente, principalmente as primeiras e as últimas palavras lidas. A função escreve_vetor serviu apenas para, durante a elaboração do programa, testar/conferir os valores das variáveis vetor. Por último, queria sugerir três possíveis melhorias para uma nova versão do jogo, a saber: - Resolver o problema de uma possível palavra ter mais do que 10 letras diferentes, ou seja, mais letras que tentativas, tornando possível ganhar o jogo neste caso; - Acrescentar uma mensagem para avisar o utilizador caso já tenha escolhido uma mesma letra numa tentativa anterior; - Corrigir a parte estética do programa quando o utilizador acerta na 10º tentativa.
